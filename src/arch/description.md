В этой папке(src/arch), будут храниться архитектурно зависимый код, у каждой архитекутры он состоит из двух вещей:
- "Bootloader" ("Загрузчик")
- Arch-depented init (Архитектурно-зависимая инициализация)

# 1. Bootloader ("Загрузчик")
> Это часть, которую грузит реальный загрузчик(например GNU GRUB v2.0), и она подготавливает загрузку уже центрального ядра SNK.
---
Пример(для x86):
> Тут "загрузчик" разделен на две части, в основном так везде(в каждой архитектуре).

Первая часть:
> 1. Подготовка начальной GDT
> 2. Подготовка базовой виртуальной памяти(identity mapping и higher half kernel mapping памяти)

Вторая часть(функция kboot):
> 1. В функцию, которая уже находиться в higher half kernel кстати, передаются архитектурно зависимые параметры загрузчика(пока что это значение из eax и ebx - магия и указатель на структуру multiboot/multiboot2 соотвественно). Эти параметры она парсит в общую структуру, которую принимает основная функция ядра(kmain), кстати потом эта функция обратно передается в Arch-depented init(Архитектурно-зависимая инициализация)
> 2. Запуск, и передача как параметр готовой, стандартизированной для всех архитектур структуры, функции kmain

# 2. Arch-depented init (Архитектурно-зависимая инициализация)
> Это часть, которая работает уже после передачи управления в The SNK Kernel(в функцию kmain)

Из первой части архитектуры, можно выделить, что загрузчик неизменяемого The SNK Kernel проводит базовую инициализацию, которой будет достаточно для запуска kmain.
После передачи управления, ядро создает новый обьект подобный классу `Arch`:
```cpp
extern "C" void kmain(bootsystem_struct* bootsystem){
    Arch kernel_arch(bootsystem);
    // ...Код...
    kernel_arch.finalize_setup();
    // ...Код...
}
```
> Это базовый пример, тут даже не реализована выборка `класса архитектуры`

При инициализации, в конструктор передается та самая `структура независимой от архитектуры загрузки`, и в конструкторе мы иницализируем все остальные вещи уже правильно и полностью(К примеру для x86 можно привести: инициализацию менеджеров физической и виртуальной памяти, настройка таблицы дексрипторов прерываний(IDT), настройка правильной глобальной таблицы дескрипторов(GDT) и т.п.)

При этом, какие либо ошибки и прерывания исполнения(например kpanic) запрещены на этом этапе,
но для проверки того, что архитектура правильно стартовала есть метод `kernel_arch.finalize_setup()`:
После передачи управления данная функция проверяет корректность выполенения инициализации в конструкторе, уже может выдавать ошибки и прерывания исполнения(типо kpanic).
